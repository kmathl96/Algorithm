# 파이프 옮기기 1
# 다이나믹 프로그래밍

N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

# 해당 위치까지 갈 수 있는(파이프의 오른쪽 끝이 해당 위치에 놓여있는) 방법의 수 저장
# 윗행, 왼쪽 열의 영향을 받으므로 입력 받는 행렬보다 1씩 더 크게 만들고 0으로 초기화
# dp[row][col] = [가로, 대각성, 세로] (파이프의 오른쪽 끝을 각 방향으로 놓을 수 있는 방법의 수)
dp = [[[0]*3 for _ in range(N+1)] for k in range(N+1)]

# 입력 행렬의 1행 1, 2열(dp[1][2])에 가로(dp[1][2][0]) 파이프가 놓여있음
dp[1][2][0] = 1
for r in range(1,N+1):
    for c in range(3,N+1): # 입력 행렬의 1, 2열에는 파이프를 놓을 수 없으므로 3열부터 고려
        if arr[r-1][c-1]: continue # 벽이 있는 경우 파이프를 놓을 수 없음
        # 왼쪽 열의 파이프가 가로(0), 대각선(1)으로 놓여있었을 경우 해당 위치로 가로(0)로 놓을 수 있음
        dp[r][c][0] = dp[r][c-1][0]+dp[r][c-1][1]
        # 윗행의 파이프가 세로(2), 대각선(1)으로 놓여있었을 경우 해당 위치로 세로(2)로 놓을 수 있음
        dp[r][c][2] = dp[r-1][c][1]+dp[r-1][c][2]
        if arr[r-2][c-1] or arr[r-1][c-2]: continue # 윗행 또는 왼쪽 열에 벽이 있을 경우 해당 위치에 대각선으로 놓을 수 없음
        # 윗행 왼쪽 열의 파이프는 어떤 방향으로 놓여있든, 해당 위치로 대각선(1)으로 놓을 수 있음
        dp[r][c][1] = sum(dp[r-1][c-1])
print(sum(dp[N][N]))