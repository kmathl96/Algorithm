# 연속합 2
# 다이나믹 프로그래밍

n = int(input())
num = list(map(int,input().split()))

# dp[0] : 아무 수도 제거하지 않은, 각각의 경우의 최대 연속합
# dp[1] : 특정 수를 제거한, 각각의 경우의 최대 연속합
dp = [[-1000]*n for _ in range(2)] # 입력값의 최솟값인 -1000으로 최소화
for i in range(n):
    # dp[0]은 백준 1912. 연속합 문제에서처럼,
    # 앞의 연속합에 i번째 수를 더했을 때의 값(dp[i-1]+num[i])과
    # i번째 수를 시작점으로 두는 경우의 값(num[i])을 비교하여 더 큰 값 저장
    dp[0][i] = max(num[i], dp[0][i-1]+num[i])

    # dp[1]은 특정 값을 제거했을 때의 최댓값을 저장
    # 1. i번째 수를 제거하는 경우 => 직전 순서에서 아무 것도 제거하지 않았을 때의 연속합(dp[0][i-1])
    # 2. 이미 제거된 상태 => 직전 순서에서 특정 수를 제거했을 때의 연속합(dp[1][i-1])에 자신의 값(num[i])을 더한 값
    dp[1][i] = max(dp[0][i-1], dp[1][i-1]+num[i])
print(max(max(dp[0]),max(dp[1]))) # dp[0]의 최댓값과 dp[1]의 최댓값 중 더 큰 값 출력