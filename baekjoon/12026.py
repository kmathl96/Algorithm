# BOJ 거리
# DP

N = int(input()) # 도로에 놓여진 보도블록의 개수
road = input() # 보도블록에 쓰여 있는 글자
dp = [1000000]*N # 각각의 보도블록에 도착하는 데 필요한 에너지의 양의 최솟값
dp[0] = 0 # 스타트의 집은 1번째 블록에 있음

# i번째 보도블록에서 점프
for i in range(N):
    # 초기 값과 똑같다면, 이 보도블록에 도착할 수 없는 것이므로 넘어감 (점프 불가능)
    if dp[i] == 1000000: continue

    # 현재 보도블록에 쓰여있는 글자에 맞게 다음 보도블록으로 점프
    # B -> O -> J -> B -> ... 순서대로 감
    if road[i] == 'B': nxt = 'O'
    elif road[i] == 'O': nxt = 'J'
    else: nxt = 'B'

    # 현재 보도블록의 다음 보도블록부터 마지막 보도블록까지 탐색
    for j in range(i+1,N):
        # 다음 글자가 적혀있는 보도블록이라면 점프
        if road[j]==nxt:
            # 이전에 저장했던 에너지와 해당 보도블록에서 점프했을 때의 에너지를 비교해서 갱신
            dp[j] = min(dp[j],dp[i]+(j-i)**2)

# 마지막 보도블록의 값이 초기 값과 똑같다면, 링크의 집에 도착할 수 없는 것이므로 -1 출력
print(-1 if dp[N-1]==1000000 else dp[N-1])