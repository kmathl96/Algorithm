# 2개 이하로 다른 비트
# 월간 코드 챌린지 시즌2

def solution(numbers):
    answer = []
    # f(x) = x보다 크고 x와 비트가 1~개 다른 수들 중에서 제일 작은 수
    for x in numbers:
        # 1. x가 홀수인 경우
        # x의 비트 오른쪽 끝 연속된 1 중 제일 왼쪽 1의 위치의 값을 더하면
        # 그 왼쪽 자리 비트는 0에서 1로, 그 자리 비트는 1에서 0으로 바뀜
        # ex1) x = 7 = 000...0111 => 맨오른쪽 1 중 제일 왼쪽 1의 위치 = 3
        #      000...0111 + 000...0100 = 000...1011
        #      오른쪽에서 4번째 자리는 0에서 1, 3번째 자리는 1에서 0으로 바뀜
        #      (000...`01`11 => 000...`10`11)
        # ex2) x = 11 = 000...1011 => 맨오른쪽 1 중 제일 왼쪽 1의 위치 = 2
        #      000...1011 + 000...0010 = 000...1101
        #      오른쪽에서 3번째 자리는 0에서 1, 2번째 자리는 1에서 0으로 바뀜
        #      (000...1`01`1 => 000...1`10`1)
        # => x에 더한 값 = 2**(맨오른쪽 연속된 1의 개수-1)
        if x&1:
            # x의 비트 오른쪽 끝 1의 개수 세기
            n,cnt = x//2,1 # cnt : x의 비트 끝 연속된 1의 개수
            while n&1: # 0이 되면 종료
                n //= 2
                cnt += 1
            answer.append(x+2**(cnt-1)) # f(x) = x + 2**(비트 끝 1의 개수(cnt) - 1)
        # 2. x가 짝수인 경우
        # x의 비트 끝자리가 0임
        # 그 다음 수의 비트 끝자리는 1이고 나머지 비트는 같음
        else: answer.append(x+1) # f(x) = x+1
    return answer

print(solution([2,7])) # [3,11]